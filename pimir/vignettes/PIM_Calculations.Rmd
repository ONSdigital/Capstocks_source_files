---
title: "PIM Calculations"
author: "Adnan Fiaz"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PIM Calculations}
  %\VignetteEngine{rmarkdown::render}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo=FALSE, message = FALSE, warning = FALSE, fig.width=6, fig.height=5)
devtools::load_all("..")
library(dplyr)
library(ggplot2)
```

The purpose of the perpetual inventory method (PIM) is to calculate a stock value based on a gross fixed capital formation (GFCF) value and a retirement distribution. The PIM also accepts a time series of GFCF to produce a time series of stock values. In this case each time point can have a different retirement distribution. We will go through this in more detail when discussing the different functions. 

The above stock value is a gross stock value. The PIM implementation we will discuss is further enhanced with an age-price or age-efficiency profile to produce net and productive stock. 

## The input data

The main entry point into the package is the `run` function. This expects three inputs:

* A time series of GFCF
* A time series of life length minimum, maximum, average and coefficient of variations in a data.frame
* A configuration object

The time series GFCF is a simple numeric vector like below:
```{r, echo=FALSE}
set.seed(28072017)
round(runif(10) * 100, 2)
```

The time series of life length values is more complex in that it must have four values arranged in a data.frame with the correct column headers. Each entry must correspond to an entry in the time series of GFCF although this isn't enforced.
```{r, results='asis'}
library(knitr)
set.seed(28072017)
ll <- data.frame(Min=rpois(10, lambda=5), Max=rpois(10, lambda=50), Average=rpois(10, lambda=25), CoV=round(runif(10), 2))
kable(ll)
```

And finally the configuration object is generated by calling the `pimConfig` function. All configuration parameters have a default value so read the documentation to see which ones need to be changed. When calling the function without specifying any arguments this will return the following (an R list object):
```{r}
pimir::pimConfig()
```

This object can be passed on to the `run` function.

## The output data

Before we dive into the different steps within the `run` function we will now discuss the output. As mentioned in the introduction this implementation of the PIM calculates the gross stock, net stock and productive stock. These are returned in a data.frame that will look like the following (values are made up):
```{r}
set.seed(29072017)
output <- data.frame(GrossStock = round(cumsum(runif(10)*100), 2), 
                     ProductiveStock = round(cumsum(runif(10)*100), 2),
                     NetStock = round(cumsum(runif(10)*100), 2))
kable(output)
```

## A step-by-step

As a user of the **pimir** package you will only use the `run` and `pimConfig` functions. Nevertheless it may be useful to know what else is done to create the above outputs. 

### Retirement distribution

The value of investments decline as they age, that is what is captured by the retirement distribution. The first step of the `run` function is to calculate survival values based on the retirement distribution. The distribution is defined by it's average, coefficient of variation, maximum age, minimum age and a probability distribution. The latter is defined through the `pimConfig` function. All these inputs are then provided to the `calcSurvivalValues` function. Although the probability distribution applies to the entire time series of investments, the distribution parameters do not. These too can be a time series and for each record in the time series a vector of survival values is calculated. Below is an example where there is one record in the time series.
```{r}
retdist <- data.frame(Min=2, Max=40, Average=25, CoV=0.5)
kable(retdist)
```

So when we forward these values to the `calcSurvivalValues` function we obtain a vector of survival values starting from age = 0 to age = maximum age.

```{r}
pc <- pimir::pimConfig()
sv <- pimir:::calcSurvivalValues(retdist, pc)

qplot(x=1:length(sv$values[[1]]), y=sv$values[[1]]) + 
  labs(title="Survival Values for one retirement distribution",
                                   x="Time", y="Probability of survival")
```

The output of the function is a data.frame of the same length as the time series of distribution parameters. Each row in this data.frame will have it's own vector of survival values corresponding to the survival values for investments in that period in time. So if we expand our previous example with more records we can generate more vectors of survival values:
```{r}
retdist <- data.frame(Min=c(2, 2, 2, 2), Max=c(40, 45, 35, 50), 
                      Average=c(25, 30, 20, 33), CoV=c(0.5, 0.5, 0.5, 0.5))
kable(retdist)
```


```{r}
sv <- pimir:::calcSurvivalValues(retdist, pc)
values <-  do.call(c, purrr::flatten(sv$values))
sv <- data.frame(Age = rep(factor(sv$vintageId), each=length(sv$values[[1]])), 
                 Values=values,
                 Time = rep(seq(length(sv$values[[1]])), nrow(sv)))
qplot(x= Time, y=Values, data=sv, colour=Age, shape=Age) +
  labs(title="Survival Values for four retirement distributions",
                                   x="Time", y="Probability of survival")
```

### Gross Stock
The next step is the first use of the actual `pim` function which is when we calculate the Gross Stock. This is where we cumulatively sum the time series of investments. However we must take into account the retirement distribution of each investment so we multiply it by the survival values before summing.

The `pim` function accomplishes this all by first converting the survival values into an upper triangular matrix which is subsequently matrix multiplied by the time series of GFCF. The result is a time series of Gross Stock such as the one in the graph below:

```{r}
gfcf <- c(325.6, 214.7, 259.3, 159.5, 177.4, 390.7, 380.4, 546.8, 506.1)
ll <- data.frame(Min = rep(2, length(gfcf)), Max = rep(15, length(gfcf)),
                 Average = rep(7, length(gfcf)), CoV = rep(3/7, length(gfcf)))
sv <- pimir:::calcSurvivalValues(ll, pimConfig())
gs <- pimir:::pim(gfcf, sv)
plotData <- data.frame(Time = rep(1:length(gfcf), 2), 
                       Values = c(gfcf, gs), 
                       Type = rep(c("GFCF", "Gross Stock"), each=length(gfcf)))
qplot(x=Time, y=Values, data=plotData, colour=Type, geom="line") +
  labs(title="GFCF and Gross Stock over time", x="Time", y="Value")
```

### Net/Productive Stock
The final two steps of the `run` function calculate the Net Stock (`calcNetStock`) and the Productive Stock (`calcProductiveStock`). Both functions accept the same input parameters and their output is also of the same format (a time series of Net/Productive Stock). The difference with Gross Stock is that we must now also correct for the decline of value (age-price) and the decline of efficiency (age-efficiency). Both of these profiles are parameterised in their own way via the `pimConfig` function. So before we apply the `pim` function we must combine the survival values with the age-price/age-efficiency profile. This _cohortProfile_ is calculated by the `calcCohortProfile` function before being passed on to the `pim` function. 

The `pim` function again takes the cohortProfile (for each period in the time series of GFCF) and converts it into an upper triangular matrix which is matrix multiplied by the time series of GFCF. We can add the result of the computation to the above graph.

```{r}
config <- pimConfig(inflationRate=0.02, discountRate=0.05)
ns <- pimir:::calcNetStock(gfcf, sv, config)
ps <- pimir:::calcProductiveStock(gfcf, sv, config)
newData <- data.frame(Time = rep(1:length(gfcf), 2), 
                       Values = c(ns, ps), 
                       Type = rep(c("Net Stock", "Productive Stock"), each=length(gfcf)))
plotData <- rbind(plotData, newData)

qplot(x=Time, y=Values, data=plotData, colour=Type, geom="line") +
  labs(title="GFCF and Stock over time", x="Time", y="Value")
```




